diversity(x, index = "simpson", groups = 6, equalize.groups = FALSE, MARGIN = 1, base = exp(1))
simpson.unb(x, inverse = FALSE)
data(BCI, BCI.env)
H <- diversity(BCI)
simp <- diversity(BCI, "simpson")
invsimp <- diversity(BCI, "inv")
library(diveRsity)
x <- c(15, 6, 4, 0, 3, 0)
diversity(x, index = "simpson", groups = 6, equalize.groups = FALSE, MARGIN = 1, base = exp(1))
simpson.unb(x, inverse = FALSE)
x <- c(12, 4, 3, 1, 2, 1)
diversity(x, index = "invsimpson", groups = 6, equalize.groups = FALSE, MARGIN = 1, base = exp(1))
invsimpson(x, "invsimpson")
invsimpson(x, inverse = TRUE)
x <- c(12, 4, 3, 1, 2, 1)
diversity(x, index = "invsimpson", groups = 6, equalize.groups = FALSE, MARGIN = 1, base = exp(1))
invsimpson(x, inverse = TRUE)
invsimpson(x, "invsimpson")
x <- c(12, 4, 3, 1, 2, 1)
diversity(x, index = "invsimpson", groups = 6, equalize.groups = FALSE, MARGIN = 1, base = exp(1))
invsimp(x, "invsimp")
invsimp(x, "inversesimpson")
invsimp(x, inverse = TRUE)
library(vegan)
library(permute)
library(lattice)
library(diveRsity)
x <- c(15, 6, 4, 0, 3, 0)
diversity(x, index = "simpson", groups = 6, equalize.groups = FALSE, MARGIN = 1, base = exp(1))
x <- c(12, 4, 3, 1, 2, 1)
diversity(x, index = "invsimpson", groups = 6, equalize.groups = FALSE, MARGIN = 1, base = exp(1))
x <- c(12, 4, 3, 1, 2, 1)
diversity(x, index = "invsimpson", groups = 6, equalize.groups = FALSE, MARGIN = 1, base = exp(1))
setwd("C:/GitHub/morgan")
jpeg(file = "Thomas Genetic Drift Reference Manual Example.jpeg", width = 4, height = 3)
jpeg(file = "Thomas Genetic Drift Reference Manual Example.jpeg", width = 3, height = 2)
jpeg(file = "Thomas Genetic Drift Reference Manual Example.jpeg")
par(family = "serif")
dev.off()
jpeg(file = "Thomas Genetic Drift Manipulated Example.jpeg")
par(family = "serif")
dev.off()
library(learnPopGen)
genetic.drift(p0=0.7, Ne=50, nrep=25, time=150, show="genotypes", pause=0.1)
object<-genetic.drift(p0=0.7, Ne=50, nrep=25, time=150, show="genotypes", pause=0.1)
plot(object,show="genotypes")
jpeg(file = "Thomas Genetic Drift Manipulated Example.jpeg")
par(family = "serif")
dev.off()
library(learnPopGen)
genetic.drift(p0=0.5, Ne=20, nrep=10, time=100, show="p", pause=0.1)
object<-genetic.drift(p0=0.5, Ne=20, nrep=10, time=100, show="p", pause=0.1)
plot(object,show="p")
setwd("C:/GitHub/morgan")
jpeg(file = "Thomas Genetic Drift Ref Manual Example.jpeg")
par(family = "serif")
dev.off()
data <- read.csv(file=("C:/GitHub/morgan/Week 5/Figure4Data.csv"), header=T)
#(1) Poisson
one.col <- data$Num.Cells.Progeny
hist(one.col, main = "Number of Cells in Progeny")
fitp <- fitdist(c(na.exclude(one.col)), distr = "pois")
fitp
library(fitdistrplus)
library(logspline)
#(1) Poisson
one.col <- data$Num.Cells.Progeny
hist(one.col, main = "Number of Cells in Progeny")
fitp <- fitdist(c(na.exclude(one.col)), distr = "pois")
fitp
#(1) Negative Binomial
one.col <- data$Num.Cells.Progeny
hist(one.col, main = "Number of Cells in Progeny")
fitnb <- fitdist(c(na.exclude(one.col)), distr = "nbinom")
fitnb
#(1) Logistic
one.col <- data$Num.Cells.Progeny
hist(one.col, main = "Number of Cells in Progeny")
fit.logis <- fitdist(c(na.exclude(one.col)), distr = "logis")
fit.logis
gofstat(list(fitp, fitnb, fit.logis))
fits = lapply(fitnames, function(i){fitdist(prob, distr = i, method = "mle")})
fits = lapply(fitp, fitnb, fit.logis, function(i){fitdist(prob, distr = i, method = "mle")})
data <- read.csv(file=("C:/GitHub/morgan/Week 5/Figure4Data.csv"), header=T)
library(fitdistrplus)
library(logspline)
#(1) Poisson
one.col <- data$Num.Cells.Progeny
hist(one.col, main = "Number of Cells in Progeny")
fitp <- fitdist(c(na.exclude(one.col)), distr = "pois")
fitp
#(1) Negative Binomial
one.col <- data$Num.Cells.Progeny
hist(one.col, main = "Number of Cells in Progeny")
fitnb <- fitdist(c(na.exclude(one.col)), distr = "nbinom")
fitnb
#(1) Logistic
one.col <- data$Num.Cells.Progeny
hist(one.col, main = "Number of Cells in Progeny")
fit.logis <- fitdist(c(na.exclude(one.col)), distr = "logis")
fit.logis
gofstat(list(fitp, fitnb, fit.logis))
one.col <- data$Num.Cells.Progeny
hist(one.col, main = "Number of Cells in Progeny")
fitp <- fitdist(c(na.exclude(one.col)), distr = "pois")
fitp
#(1) Negative Binomial
one.col <- data$Num.Cells.Progeny
hist(one.col, main = "Number of Cells in Progeny")
fitnb <- fitdist(c(na.exclude(one.col)), distr = "nbinom")
fitnb
#(1) Logistic
one.col <- data$Num.Cells.Progeny
hist(one.col, main = "Number of Cells in Progeny")
fit.logis <- fitdist(c(na.exclude(one.col)), distr = "logis")
fit.logis
fits <- lapply(fitp, fitnb, fit.logis, function(i){fitdist(prob, distr = i, method = "mle")})
gofstat(list(fitp, fitnb, fit.logis), chisqbreaks=c(1,2,4,8,16,32,64))
gofstat(list(fitp, fitnb, fit.logis), chisqbreaks=c(1,2,4,8,16,32,64))
one.col <- data$Num.Cells.Progeny
hist(one.col, main = "Number of Cells in Progeny")
fitp <- fitdist(c(na.exclude(one.col)), distr = "pois")
fitp
#(1) Negative Binomial
one.col <- data$Num.Cells.Progeny
hist(one.col, main = "Number of Cells in Progeny")
fitnb <- fitdist(c(na.exclude(one.col)), distr = "nbinom")
fitnb
#(1) Logistic
one.col <- data$Num.Cells.Progeny
hist(one.col, main = "Number of Cells in Progeny")
fit.logis <- fitdist(c(na.exclude(one.col)), distr = "logis")
fit.logis
gofstat(list(fitp, fitnb, fit.logis), chisqbreaks=c(1,2,4,8,16,32,64))
one.col <- data$Num.Cells.Progeny
hist(one.col, main = "Number of Cells in Progeny")
fitp <- fitdist(c(na.exclude(one.col)), distr = "pois")
fitp
#(1) Negative Binomial
one.col <- data$Num.Cells.Progeny
hist(one.col, main = "Number of Cells in Progeny")
fitnb <- fitdist(c(na.exclude(one.col)), distr = "nbinom")
fitnb
#(1) Logistic
one.col <- data$Num.Cells.Progeny
hist(one.col, main = "Number of Cells in Progeny")
fit.logis <- fitdist(c(na.exclude(one.col)), distr = "logis")
fit.logis
gofstat(list(fitp, fitnb, fit.logis), chisqbreaks=c(1,2,4,8,16,32,64))
one.col <- data$RepTime.sec
hist(one.col, main = "Replication Time")
fitp <- fitdist(c(na.exclude(one.col)), distr = "pois")
fitp
#(2) Negative Binomial
one.col <- data$RepTime.sec
hist(one.col, main = "Replication Time")
fitnb <- fitdist(c(na.exclude(one.col)), distr = "nbinom")
fitnb
#(2) Logistic
one.col <- data$RepTime.sec
hist(one.col, main = "Replication Time")
fit.logis <- fitdist(c(na.exclude(one.col)), distr = "logis")
fit.logis
gofstat(list(fitp, fitnb, fit.logis), chisqbreaks=c(1,2,4,8,16,32,64))
one.col <- data$RepTime.sec
hist(one.col, main = "Time")
fit.norm <- fitdist(one.col*100, distr = "norm")
hist(one.col, main = "Replication Time")
fit.norm <- fitdist(one.col*100, distr = "norm")
plot(fit.norm)
one.col <- data$RepTime.sec
hist(one.col, main = "Replication Time")
fit.norm <- fitdist(c(na.exclude(one.col)), distr = "norm")
plot(fit.norm)
one.col <- data$RepTime.sec
hist(one.col, main = "Replication Time")
one.col?
one.col?
?one.col
library(MASS)
library (MuMIn)
library(mgcv)
install.packages(MuMIn)
library (MuMIn)
install.packages(MuMIn)
install.packages("MuMIn")
library (MuMIn)
library(mgcv)
setwd("C:/GitHub/morgan/Week6")
df <- read.csv("Toscano_Griffen_Data.csv")
df
data <- read.csv(file=("C:/GitHub/morgan/Week 6/Toscano_Griffen_Data.csv"), header=T)
df
df <- read.csv(file=("C:/GitHub/morgan/Week 6/Toscano_Griffen_Data.csv"), header=T)
df
#Additive Effects
gam.mod1 <- gam(activity.level~claw.width + carapace.width + toadfish.cue.treatment, family = binomial, random = list(ID=~ 1), data = df)
summary(gam.mod1)
r.squaredGAM(gam.mod1)
r.squared(gam.mod1)
#Additive Effects
glmm.mod1 <- glmmPQL(activity.level~claw.width + carapace.width + toadfish.cue.treatment, family = binomial, random = ~ 1 | ID, data = df)
df
#Additive Effects
glmm.mod1 <- glmmPQL(activity.level~claw.width + carapace.width + toadfish.cue.treatment, family = binomial, random = ~ 1 | ID, data = df)
# Re-run both models as generalized additive models instead (using gam). Then compare the AIC of both models. (4 points each)
#Additive Effects
gam.mod1 <- gam(activity.level~claw.width + carapace.width + toadfish.cue.treatment, family = binomial, random = list(ID=~ 1), data = df)
summary(gam.mod1)
# Re-run both models as generalized additive models instead (using gam). Then compare the AIC of both models. (4 points each)
#Additive Effects
gam.mod1 <- gam(activity.level~claw.width + carapace.width + toadfish.cue.treatment, family = binomial, random = list(ID=~ 1), data = df)
summary(gam.mod1)
#Interactive Effect
gam.mod2 <- gam(activity.level~claw.width * carapace.width * toadfish.cue.treatment, family = binomial, random = list(ID=~ 1), data = df)
summary(gam.mod2)
#Interactive Effect
gam.mod2 <- gam(activity.level~claw.width * carapace.width * toadfish.cue.treatment, family = binomial, random = list(ID=~ 1), data = df)
summary(gam.mod2)
AIC(gam.mod1, gam.mod2)
# (Q5) - Based on the residuals of your generalized additive models, how confident are you in these results? (2 pts)
plot(gam.mod1$residuals, ylim = c(-.1,.1))
# (Q5) - Based on the residuals of your generalized additive models, how confident are you in these results? (2 pts)
plot(gam.mod1$residuals, ylim = c(-.1,.1))
plot(gam.mod2$residuals, ylim = c(-.1,.1))
# (Q5) - Based on the residuals of your generalized additive models, how confident are you in these results? (2 pts)
plot(gam.mod1$residuals, ylim = c(-.1,.1))
plot(gam.mod2$residuals, ylim = c(-.1,.1))
df
#Additive Effects
glmm.mod1 <- glmmPQL(activity.level~claw.width + carapace.width + toadfish.cue.treatment, family = binomial, random = ~ 1 | ID, data = df)
summary(glmm.mod1)
#Interactive Effect
glmm.mod2 <- glmmPQL(activity.level~claw.width + carapace.width * toadfish.cue.treatment, family = binomial, random = ~ 1 | ID, data = df)
summary(glmm.mod2)
df <- read.csv("Uchidaetal_2019_Data.csv")
setwd("C:/GitHub/R4Eco_2022/Week6")
df <- read.csv("Uchidaetal_2019_Data.csv")
# Take a look and see what our data look like this week:
head(df)
# To start, we are going to use a assume a normal (aka Gaussian) distribution because we are using a linear model:
# The argument "random = ~ 1 | ID" is used to specify individual as a random effect.
# The "~ 1 |" notation is common across model functions to signify a random effect.
# The 'family' argument is used to specify the distribution family.
# Options for this can be found by looking up ?family.
# Otherwise this function should look very similar to the arguments in the lm() function for fixed effects.
glmm.mod <- glmmPQL(Flight.initiation.distance..FID.~Object, family = gaussian, random = ~ 1 | ID, data = df)
df
head(df)
#Additive Effects
glmm.mod1 <- glmmPQL(activity.level~claw.width + carapace.width + toadfish.cue.treatment, family = binomial, random = ~ 1 | ID, data = df)
summary(glmm.mod1)
#Additive Effects
glmm.mod1 <- glmmPQL(activity.level~claw.width + carapace.width + toadfish.cue.treatment, family = binomial, random = ~ 1 | ID, data = df)
# The authors used proportional consumption of prey as the (y) in their model, but did not include this in the dataset.
# So we are going to create it - run the following line, assuming df= your data frame (feel free to change that):
df$prop.cons <- df$eaten/df$prey
df <- read.csv(file=("C:/GitHub/morgan/Week 6/Toscano_Griffen_Data.csv"), header=T)
df
head(df)
#Additive Effects
glmm.mod1 <- glmmPQL(activity.level~claw.width + carapace.width + toadfish.cue.treatment, family = binomial, random = ~ 1 | block, data = df)
library(MASS)
library (MuMIn)
library(mgcv)
#Additive Effects
glmm.mod1 <- glmmPQL(activity.level~claw.width + carapace.width + toadfish.cue.treatment, family = binomial, random = ~ 1 | block, data = df)
summary(glmm.mod1)
r.squaredGLMM(glmm.mod1)
r.squaredGLMM(glmm.mod1)
#Interactive Effect
glmm.mod2 <- glmmPQL(activity.level~claw.width + carapace.width * toadfish.cue.treatment, family = binomial, random = ~ 1 | block, data = df)
summary(glmm.mod2)
# The authors used proportional consumption of prey as the (y) in their model, but did not include this in the dataset.
# So we are going to create it - run the following line, assuming df= your data frame (feel free to change that):
df$prop.cons <- df$eaten/df$prey
# (Q3) - Plot the residuals of both models. Do you think either model is a good fit? Why or why not? (3 pts)
plot(glmm.mod1$residuals, ylim = c(-.1,.1))
plot(glmm.mod2$residuals, ylim = c(-.1,.1))
#Additive Effects
glmm.mod1 <- glmmPQL(activity.level~claw.width + carapace.width + toadfish.cue.treatment, family = binomial, random = ~ 1 | block, data = df)
summary(glmm.mod1)
#Interactive Effect
glmm.mod2 <- glmmPQL(activity.level~claw.width + carapace.width * toadfish.cue.treatment, family = binomial, random = ~ 1 | block, data = df)
summary(glmm.mod2)
df
#Additive Effects
glmm.mod1 <- glmmPQL(activity.level~claw.width + carapace.width + toadfish.cue.treatment, family = binomial, random = ~ 1 | block, data = df)
summary(glmm.mod1)
#Interactive Effect
glmm.mod2 <- glmmPQL(activity.level~claw.width * carapace.width + toadfish.cue.treatment, family = binomial, random = ~ 1 | block, data = df)
summary(glmm.mod2)
library(MASS)
library (MuMIn)
library(mgcv)
df <- read.csv(file=("C:/GitHub/morgan/Week 6/Toscano_Griffen_Data.csv"), header=T)
df
head(df)
#Additive Effects
glmm.mod1 <- glmmPQL(activity.level~claw.width + carapace.width + toadfish.cue.treatment, family = binomial, random = ~ 1 | block, data = df)
summary(glmm.mod1)
#Interactive Effect
glmm.mod2 <- glmmPQL(activity.level~claw.width * carapace.width + toadfish.cue.treatment, family = binomial, random = ~ 1 | block, data = df)
summary(glmm.mod2)
# The authors used proportional consumption of prey as the (y) in their model, but did not include this in the dataset.
# So we are going to create it - run the following line, assuming df= your data frame (feel free to change that):
df$prop.cons <- df$eaten/df$prey
df$prop.cons
library("anytime")
install.packages("anytime")
library("anytime")
library("ggplot2")
data <- read.csv(file=("C:/GitHub/morgan/Week 7/Plankton_move_average.csv"), header=T)
data
head(data)
#Used the following lines to format the date and remove NAs from the dataset:
data$Date <- as.Date(data$Date, origin = "0001-01-01") # Setting values to "day zero".
data <- na.omit(data)
data
head(data)
#Plot these population data over time with the following code:
ggplot(data)  +
xlab("Numeric Date") + ylab("Density Individuals")+
geom_line(data=data, aes(Date, D.mendotae), color="black", alpha = 0.7, size=1)+
geom_line(data=data, aes(Date, LimncalanusF+LimncalanusM), color="orange",  alpha = 0.7, size=1)+ # adding males and females together, hint: this is actually spelled Limnocalanus
geom_line(data=data, aes(Date, Bythotrephes), color="sky blue",  alpha = 0.7, size=1)+
geom_line(data=data, aes(Date, Bythotrephes), color="sky blue",  alpha = 0.7, size=1)+
theme_bw()
#Now copy/paste in the Lotka-Volterra function, plotting script, and load the "deSolve" package from the tutorial:
LotVmod <- function (Time, State, Pars) {
with(as.list(c(State, Pars)), {
dx = x*(alpha - beta*y)
dy = -y*(gamma - delta*x)
return(list(c(dx, dy)))
})
}
Pars <- c(alpha = 2, beta = 0.5, gamma = .2, delta = .6) #This is the line we will change
State <- c(x = 10, y = 10)#For now keep this the same.
Time <- seq(0, 100, by = 1)#For now keep this the same.
#Now copy/paste in the Lotka-Volterra function, plotting script, and load the "deSolve" package from the tutorial:
LotVmod <- function (Time, State, Pars) {
with(as.list(c(State, Pars)), {
dx = x*(alpha - beta*y)
dy = -y*(gamma - delta*x)
return(list(c(dx, dy)))
})
}
library(deSolve)
# Population growth over time in isolation ####
library("growthrates")
# This is an example dataset from the growthrates package.
data(bactgrowth)
# Most important for us, these data include bacterial strain, density, and antibiotic concentration (Tetracycline) through time.
# The following lines will process these data to structure them to be read by the all_growthmodels() function.
# This pre-processing of the data follows the example from ?all_growthmodels:
splitted.data <- multisplit(value ~ time | strain + conc + replicate,
data = bactgrowth)
# Show which experiments are in splitted.data
names(splitted.data)
# Get table from single experiment
dat <- splitted.data[["D:0:1"]]
fit0 <- fit_spline(dat$time, dat$value)
fit1 <- all_splines(value ~ time | strain + conc + replicate,
data = bactgrowth, spar = 0.5)
# These examples require some CPU power and may take a bit longer
# Initial parameters
p <- c(coef(fit0), K = max(dat$value))
# avoid negative parameters
lower = c(y0 = 0, mumax = 0, K = 0)
# Now we will look at the population growth models for all strains.
all_mods <- all_growthmodels(
value ~ grow_logistic(time, parms) | strain + conc,
data = bactgrowth, p = p, lower = lower, ncores = 2)
plot(all_mods)
# Extract the observations from the model fits - this is an "S4" object. We have only worked with "S3" objects so far.
# S4 allows for a more complicated data structure that is pre-defined and creates "slots" for objects within the listed larger object.
# These are called with the "@" symbol instead of a "$".
# We can use the slot() function to subset the object.
fits_slot <- slot(all_mods, "fits")
subset_obs <- slot(fits_slot$`R:250`, "obs")
# Or you can call the vector, data frame, or other info directly through a combo of "@" and "$" depending on the object structure.
# In our case it's extra complicated and includes a nested S4 object, hence the two @ symbols.
# This will give you the same result as the slot() function from above.
R250_obs <- all_mods@fits$`R:250`@obs
# You can confirm if they match through a quick logical:
table(subset_obs==R250_obs)
# You can also call the slot directly inside of a plot:
plot(all_mods@fits$`R:250`@obs)
# To look at all 6 plots we are interested in we'll create a multipanel plot.
# This use of par() will plot 2 rows with 3 plots in each row:
par(mfrow = c(2, 3))
plot(all_mods@fits$`R:250`@obs)
plot(all_mods@fits$`T:125`@obs)
plot(all_mods@fits$`R:125`@obs)
plot(all_mods@fits$`D:62.5`@obs)
plot(all_mods@fits$`D:1.95`@obs)
plot(all_mods@fits$`D:0.24`@obs)
par(mfrow = c(2, 3))
plot(all_mods@fits$`R:250`@obs, ylim = c(0.01,0.09))
plot(all_mods@fits$`T:125`@obs, ylim = c(0.01,0.09))
plot(all_mods@fits$`R:125`@obs, ylim = c(0.01,0.09))
plot(all_mods@fits$`D:62.5`@obs, ylim = c(0.01,0.09))
plot(all_mods@fits$`D:1.95`@obs, ylim = c(0.01,0.09))
plot(all_mods@fits$`D:0.24`@obs, ylim = c(0.01,0.09))
#Code from: https://www.r-bloggers.com/lotka-volterra-model%C2%A0%C2%A0intro/
library(deSolve)
# To create these plots and view in the full window, we need to remove the par() settings for multipanel plots.
# This is done with the dev.off() function
dev.off()
LotVmod <- function (Time, State, Pars) {
with(as.list(c(State, Pars)), {
dx = x*(alpha - beta*y)
dy = -y*(gamma - delta*x)
return(list(c(dx, dy)))
})
}
Pars <- c(alpha = 2, beta = 0.5, gamma = .2, delta = .6) #This is the line we will change
State <- c(x = 10, y = 10)#For now keep this the same.
Time <- seq(0, 100, by = 1)#For now keep this the same.
out <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time)) #This is the operation that creates the Lotka-Volterra model based on our specified parameters.
#The next two lines plot the model with the predator and prey against each other.
matplot(out[,-1], type = "l", xlab = "time", ylab = "population")
legend("topright", c("Rabid foxes", "Cute bunnies"), lty = c(1,2), col = c(1,2), box.lwd = 0)
head(data)
#Plot these population data over time with the following code:
ggplot(data)  +
xlab("Numeric Date") + ylab("Density Individuals")+
geom_line(data=data, aes(Date, D.mendotae), color="black", alpha = 0.7, size=1)+
geom_line(data=data, aes(Date, LimncalanusF+LimncalanusM), color="orange",  alpha = 0.7, size=1)+ # adding males and females together, hint: this is actually spelled Limnocalanus
geom_line(data=data, aes(Date, Bythotrephes), color="sky blue",  alpha = 0.7, size=1)+
geom_line(data=data, aes(Date, Bythotrephes), color="sky blue",  alpha = 0.7, size=1)+
theme_bw()
#Now copy/paste in the Lotka-Volterra function, plotting script, and load the "deSolve" package from the tutorial:
LotVmod <- function (Time, State, Pars) {
with(as.list(c(State, Pars)), {
dx = x*(alpha - beta*y)
dy = -y*(gamma - delta*x)
return(list(c(dx, dy)))
})
}
Pars <- c(alpha = 2, beta = 0.5, gamma = .2, delta = .6) #This is the line we will change
State <- c(x = 10, y = 10)#For now keep this the same.
Time <- seq(0, 100, by = 1)#For now keep this the same.
out <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))
matplot(out[,-1], type = "l", xlab = "Numeric Date", ylab = "Density Individuals")
legend("topright", c("D. mendotae", "Limnocalanus"), lty = c(1,2), col = c(1,2), box.lwd = 0)
#Now copy/paste in the Lotka-Volterra function, plotting script, and load the "deSolve" package from the tutorial:
LotVmod <- function (Time, State, Pars) {
with(as.list(c(State, Pars)), {
dx = x*(alpha - beta*y)
dy = -y*(gamma - delta*x)
return(list(c(dx, dy)))
})
}
Pars <- c(alpha = 2, beta = 0.7, gamma = .2, delta = .6) #This is the line we will change
State <- c(x = 10, y = 10)#For now keep this the same.
Time <- seq(0, 100, by = 1)#For now keep this the same.
out <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))
matplot(out[,-1], type = "l", xlab = "Numeric Date", ylab = "Density Individuals")
legend("topright", c("D. mendotae", "Limnocalanus"), lty = c(1,2), col = c(1,2), box.lwd = 0)
matplot(out[,-1], type = "l", xlab = "Numeric Date", ylab = "Density Individuals")
legend("topright", c("D. mendotae", "Limnocalanus"), lty = c(1,2), col = c(1,2), box.lwd = 0)
matplot(out[,-1], type = "l", xlab = "Numeric Date", ylab = "Density Individuals")
data <- read.csv(file=("C:/GitHub/morgan/Week 7/Plankton_move_average.csv"), header=T)
data
head(data)
#Used the following lines to format the date and remove NAs from the dataset:
data$Date <- as.Date(data$Date, origin = "0001-01-01") # Setting values to "day zero".
data <- na.omit(data)
data
head(data)
#Plot these population data over time with the following code:
ggplot(data)  +
xlab("Numeric Date") + ylab("Density Individuals")+
geom_line(data=data, aes(Date, D.mendotae), color="black", alpha = 0.7, size=1)+
geom_line(data=data, aes(Date, LimncalanusF+LimncalanusM), color="orange",  alpha = 0.7, size=1)+ # adding males and females together, hint: this is actually spelled Limnocalanus
geom_line(data=data, aes(Date, Bythotrephes), color="sky blue",  alpha = 0.7, size=1)+
geom_line(data=data, aes(Date, Bythotrephes), color="sky blue",  alpha = 0.7, size=1)+
theme_bw()
#Now copy/paste in the Lotka-Volterra function, plotting script, and load the "deSolve" package from the tutorial:
LotVmod <- function (Time, State, Pars) {
with(as.list(c(State, Pars)), {
dx = x*(alpha - beta*y)
dy = -y*(gamma - delta*x)
return(list(c(dx, dy)))
})
}
Pars <- c(alpha = 2, beta = 0.7, gamma = .2, delta = .6) #This is the line we will change
State <- c(x = 10, y = 10)#For now keep this the same.
Time <- seq(0, 100, by = 1)#For now keep this the same.
out <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))
matplot(out[,-1], type = "l", xlab = "Numeric Date", ylab = "Density Individuals")
legend("bottomleft", c("D. mendotae", "Limnocalanus"), lty = c(1,2), col = c(1,2), box.lwd = 0)
Pars <- c(alpha = 1, beta = 0.9, gamma = .3, delta = .6) #This is the line we will change
#Now copy/paste in the Lotka-Volterra function, plotting script, and load the "deSolve" package from the tutorial:
LotVmod <- function (Time, State, Pars) {
with(as.list(c(State, Pars)), {
dx = x*(alpha - beta*y)
dy = -y*(gamma - delta*x)
return(list(c(dx, dy)))
})
}
Pars <- c(alpha = 1, beta = 0.9, gamma = .3, delta = .6) #This is the line we will change
State <- c(x = 10, y = 10)#For now keep this the same.
Time <- seq(0, 100, by = 1)#For now keep this the same.
out <- as.data.frame(ode(func = LotVmod, y = State, parms = Pars, times = Time))
matplot(out[,-1], type = "l", xlab = "Numeric Date", ylab = "Density Individuals")
legend("bottomleft", c("D. mendotae", "Limnocalanus"), lty = c(1,2), col = c(1,2), box.lwd = 0)
legend("topright", c("D. mendotae", "Limnocalanus"), lty = c(1,2), col = c(1,2), box.lwd = 0)
matplot(out[,-1], type = "l", xlab = "Numeric Date", ylab = "Density Individuals")
legend("topright", c("D. mendotae", "Limnocalanus"), lty = c(1,2), col = c(1,2), box.lwd = 0)
matplot(out[,-1], type = "l", xlab = "Numeric Date", ylab = "Density Individuals")
