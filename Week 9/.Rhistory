legend("topright", c("D. mendotae", "Limnocalanus"), lty = c(1,2), col = c(1,2), box.lwd = 0)
matplot(out[,-1], type = "l", xlab = "Numeric Date", ylab = "Density Individuals")
legend("topright", c("D. mendotae", "Limnocalanus"), lty = c(1,2), col = c(1,2), box.lwd = 0)
matplot(out[,-1], type = "l", xlab = "Numeric Date", ylab = "Density Individuals")
# First things first, load the vegan library.
# Any time you are looking at community ecology, the package is probably going to be vegan.
library(vegan)
# We will use the "dune" dataset from vegan.
# the dune data are plant communities from dune meadows.
data(dune)
# There is also a data frame of environmental factors that match the dune plants that we will use this week:
data(dune.env)
# We are focusing on Redundancy Analysis (RDA).
# But all of these methods can be transferred to other multivariate techniques very easily.
# pca() and cca() can typically just replace the rda() in any of these functions and models.
# The generic use of rda is very straightforward. All you need is a numeric species-by-site matrix.
dune #to see what I mean by a species-by-site matrix
ord <- rda(dune)
plot(ord)
# The real power of RDA is the ability to explain variance via a model.
# We'll use the dune.env data and take a quick look first to see type of data are included:
head(dune.env)
# Agriculture use typically impacts plant communities, so we will start there.
# This should look very familiar to the model syntax we have used so far.
mod1 <- rda(dune ~ Use, dune.env)
mod1
#The model call gives us constrained and unconstrained variance
# Constrained is the percent of the axes that is explained by "Use"
# Unconstrained is similar to the residuals of a linear model.
# We can also call the anova() function the same way that you would for a linear model:
anova(mod1)
# Moisture is another common driver of plant community composition
mod2 <- rda(dune ~ Moisture, dune.env)
mod2
anova(mod2)
# Just like other models, we can include additive or interactive effects as well:
# We can see what the cumulative effect of management and soil moisture is on the plant community:
mod3 <- rda(dune ~ Moisture + Management, dune.env)
mod3
anova(mod3)
#Let's plot to see what this looks like visually:
plot(mod3)
# Because of the amount of information, ordination plots are best done in layers, like adding regression lines.
# First create a blank plot where the axes are auto-fitted to the min and max values of "mod3"
plot(mod3, type="n", display = c("sites", "scores"))
# Next we will add a layer where the points are displayed with a label that represents their management
text(mod3, display="sites", labels = as.character(dune.env$Management))
# It looks like the same management types are grouping together.
# We would expect this based on our high variance explained and significant p-value.
# But statistically viewing this relationship can be difficult.
# We will draw 95% confidence intervals around the "centroid" (average score) for each management group.
# This is done with the ordiellipse() function. Notice there is an argument for the confidence interval and the grouping:
pl <- ordiellipse(mod3, dune.env$Management, kind="se", conf=0.95, lwd=2, draw = "polygon",
col="skyblue", border = "blue")
summary(pl)
# We can also group data by a factor that was not in the model to identify more complex patterns:
# We can see if the "Use" influences the communities that are already constrained by "Management":
plot(mod3, type="n", display = "sites")
text(mod3, display="sites", labels = as.character(dune.env$Use))
pl <- ordiellipse(mod3, dune.env$Use, kind="se", conf=0.95, lwd=2, draw = "polygon",
col="skyblue", border = "blue")
summary(pl)
# We can try plotting against a different axis to see if this is simply a weaker pattern obscured by Axis 1
# This requires a little data manipulation as plot() does not like to use other axes from default.
# First we need to extract the axis scores from the model
# These are found in the following two parts of the model:
Site_Scores <- mod3$CCA$u
Species_Scores <- mod3$CCA$v
head(Site_Scores)
plot(Site_Scores[,2:3], type="n")
text(Site_Scores[,2:3], labels = as.character(dune.env$Use))
pl <- ordiellipse(Site_Scores[,2:3], dune.env$Use, kind="se", conf=0.95, lwd=2, draw = "polygon",
col="skyblue", border = "blue")
rarefaction<-function(x,subsample=5, plot=TRUE, color=TRUE, error=FALSE, legend=TRUE, symbol=c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18)){
library(vegan)
x <- as.matrix(x)
y1<-apply(x, 1, sum)
rare.data<-x
select<-unique(sort(c((apply(x, 1, sum)), (seq(0,(max(y1)), by=subsample)), recursive=TRUE)))
storesummary.e<-matrix(data=NA, ncol=length(rare.data[,1]),nrow=length(select))
rownames(storesummary.e)<-c(select)
colnames(storesummary.e)<-rownames(x)
storesummary.se<-matrix(data=NA, ncol=length(rare.data[,1]),nrow=length(select))
rownames(storesummary.se)<-c(select)
colnames(storesummary.se)<-rownames(x)
for(i in 1:length(select))                      #the for loop
{
select.c<-select[i]                     #assigns the 'i'th element of select to select.c
foo<-rarefy(x,select.c, se=T)           #use whatever vegan fn you want
storesummary.e[i,]<-foo[1,]
storesummary.se[i,]<-foo[2,]
}
storesummary.e<-as.data.frame(storesummary.e)
richness.error<<-storesummary.se
for (i in 1:(length(storesummary.e)))
{
storesummary.e[,i]<-ifelse(select>sum(x[i,]), NA, storesummary.e[,i])
}
###############plot result################################
if (plot==TRUE)
{
if(color==TRUE){
plot(select,storesummary.e[,1], xlab="Individuals in Subsample",
xlim=c(0,max(select)), ylim=c(0, 5+(max(storesummary.e[,1:(length(storesummary.e))], na.rm=TRUE))),
ylab="Mean Species Richness", pch =16, col=2, type="n")
for (j in 1:(length(storesummary.e))){
points(select, storesummary.e[,j], pch=16, col=j+1, type="b", lty=1)}
if(error==TRUE){
for (m in 1:(length(storesummary.e))){
segments(select, storesummary.e[,m]+storesummary.se[,m],select, storesummary.e[,m]-storesummary.se[,m])
}
}
if (legend==TRUE){
legend("bottomright", colnames(storesummary.e), inset=0.05, lty=1, col=1:length(storesummary.e)+1, lwd=2)
}
}
else
{
plot(select,storesummary.e[,1], xlab="Individuals in Subsample",
xlim=c(0,max(select)), ylim=c(0, 5+(max(storesummary.e[,1:(length(storesummary.e))], na.rm=TRUE))),
ylab="Mean Species Richness", pch =16, col=2, type="n")
for (j in 1:(length(storesummary.e))){
points(select, storesummary.e[,j], type="l", lty=1)}
for (k in 1:(length(storesummary.e))){
symbol<-ifelse(symbol<length(storesummary.e),rep(symbol,2),symbol)
points(as.numeric(rownames(subset(storesummary.e, storesummary.e[,k]==max(storesummary.e[,k],na.rm=TRUE)))), max(storesummary.e[,k],na.rm=TRUE), pch=symbol[k], cex=1.5)}
if(error==TRUE){
for (m in 1:(length(storesummary.e))){
points(select, storesummary.e[,m]+storesummary.se[,m], type="l", lty=2)
points(select, storesummary.e[,m]-storesummary.se[,m], type="l", lty=2)}}
k<-1:(length(storesummary.e))
if (legend==TRUE){
legend("bottomright", colnames(storesummary.e), pch=symbol[k], inset=0.05, cex=1.3)
}
}
}
print("rarefaction by J. Jacobs, last update April 17, 2009")
if(error==TRUE)(print("errors around lines are the se of the iterations, not true se of the means")  )
list("richness"= storesummary.e, "SE"=richness.error, "subsample"=select)
}
# We are using the "BCI" data from vegan for the example:
data(BCI)
# First take a look at the data:
head(BCI)
rarefaction(BCI, subsample=50, plot=TRUE, color=TRUE, error=FALSE,  legend=TRUE, symbol)
samples <- as.data.frame(t(rowSums(t(BCI))))
rarefaction(samples, subsample=500, plot=TRUE, color=TRUE, error=FALSE,  legend=TRUE, symbol)
# What if you want to collect just a few larger samples?
rarefaction(samples, subsample=5000, plot=TRUE, color=TRUE, error=FALSE,  legend=TRUE, symbol)
library(readxl)
Data_rabbit_abund_motorway_Dryad <- read_excel("Week 8/Data_rabbit abund motorway_Dryad.xlsx")
View(Data_rabbit_abund_motorway_Dryad)
library(readxl)
setwd("C:/GitHub/morgan/Week 9")
abiotic.tibble <- read_excel("Penaetal_2016_data.xlsx", sheet = "Abiotic factors")
abiotic <- as.data.frame(abiotic.tibble)
head(abiotic)
invert.tibble <- read_excel("Penaetal_2016_data.xlsx", sheet = "Invertebrate_community")
invert <- as.data.frame(invert.tibble)
head(invert)
abiotic.names <- paste(abiotic$Parcel, abiotic$Land_Use)
abiotic$names <- abiotic.names
head(abiotic)
invert.names <- paste(invert$Parcel, invert$Landuse)
invert$names <- invert.names
head(invert)
abiotic.means <- aggregate(x = abiotic, by = list(abiotic$names), FUN = "mean")
head(abiotic.means)
invert.means <- aggregate(x = invert, by = list(invert$names), FUN = "mean")
head(invert.means)
abiotic.means1 <- abiotic.means[,c(-2,-3,-5,-6,-16)]
abiotic.means1 <- sapply(abiotic.means1, as.numeric)
invert.means1 <- invert.means[,-2:-3]
invert.means1 <- sapply(invert.means1, as.numeric)
abiotic.means1 <- abiotic.means[,c(-2,-3,-5,-6,-16)]
abiotic.means1 <- sapply(abiotic.means1, as.numeric)
View(invert.means1)
View(invert.means)
View(invert)
abiotic.means1 <- abiotic.means[,c(-2,-3,-5,-6,-16)]
abiotic.means1 <- sapply(abiotic.means1, as.numeric)
View(abiotic.tibble)
View(abiotic.means1)
# And we can FINALLY compare the abiotic data against the biotic communities:
library(vegan)
colnames(abiotic.means2)
ord <- rda(nema.means2 ~ pH + totalN + Perc_ash + Kalium + Magnesium + Ca + Al + TotalP + OlsenP, abiotic.means2)
abiotic.means1 <- abiotic.means[,c(-2,-3,-5,-6,-16)]
abiotic.means2 <- sapply(abiotic.means1, as.numeric)
invert.means1 <- invert.means[,-2:-3]
invert.means2 <- sapply(invert.means1, as.numeric)
View(invert.tibble)
View(invert.means2)
View(invert.means1)
View(abiotic)
View(abiotic.means)
View(abiotic.means1)
View(abiotic.means2)
library(readxl)
setwd("C:/GitHub/morgan/Week 9")
abiotic.tibble <- read_excel("Penaetal_2016_data.xlsx", sheet = "Abiotic factors")
abiotic <- as.data.frame(abiotic.tibble)
head(abiotic)
invert.tibble <- read_excel("Penaetal_2016_data.xlsx", sheet = "Invertebrate_community")
invert <- as.data.frame(invert.tibble)
head(invert)
abiotic.names <- paste(abiotic$Parcel, abiotic$Land_Use)
abiotic$names <- abiotic.names
head(abiotic)
invert.names <- paste(invert$Parcel, invert$Landuse)
invert$names <- invert.names
head(invert)
abiotic.means <- aggregate(x = abiotic, by = list(abiotic$names), FUN = "mean")
head(abiotic.means)
invert.means <- aggregate(x = invert, by = list(invert$names), FUN = "mean")
head(invert.means)
abiotic.means1 <- abiotic.means[,c(-2,-3,-5,-6,-16)]
abiotic.means2 <- sapply(abiotic.means1, as.numeric)
abiotic.means2
abiotic.means1 <- abiotic.means[,c(-1,-2,-3,-5,-6,-16)]
abiotic.means2 <- sapply(abiotic.means1, as.numeric)
invert.means1 <- invert.means[,-2:-3]
invert.means2 <- sapply(invert.means1, as.numeric)
invert.means1 <- invert.means[,-1:-3]
invert.means2 <- sapply(invert.means1, as.numeric)
library(vegan)
colnames(abiotic.means2)
ord <- rda(invert.means2 ~ pH + totalN + Perc_ash + Kalium + Magnesium + Ca + Al + TotalP + OlsenP, abiotic.means2)
ord <- rda(as.data.frame(invert.means2) ~ pH + totalN + Perc_ash + Kalium + Magnesium + Ca + Al + TotalP + OlsenP, abiotic.means2)
ord <- rda(as.data.frame(invert.means2) ~ pH + totalN + Perc_ash + Kalium + Magnesium + Ca + Al + TotalP + OlsenP, as.data.frame(abiotic.means2))
abiotic.means2
invert.means2
abiotic.means1
abiotic.means
View(abiotic.means)
View(invert.means)
invert.means1 <- invert.means[-5,-1:-3]
invert.means2 <- sapply(invert.means1, as.numeric)
abiotic.means2
invert.means2
library(vegan)
colnames(abiotic.means2)
ord <- rda(as.data.frame(invert.means2) ~ pH + totalN + Perc_ash + Kalium + Magnesium + Ca + Al + TotalP + OlsenP, as.data.frame(abiotic.means2))
View(invert.means1)
View(invert.means2)
View(abiotic.means2)
abiotic.means2 <- as.data.frame(sapply(abiotic.means1, as.numeric))
View(abiotic.means2)
invert.means2 <- as.data.frame(sapply(invert.means1, as.numeric))
ord <- rda(invert.means2 ~ pH + totalN + Perc_ash + Kalium + Magnesium + Ca + Al + TotalP + OlsenP, abiotic.means2)
View(invert.means1)
View(invert.means)
invert.means1 <- invert.means[-5,c(-1:-3,-73)]
invert.means2 <- as.data.frame(sapply(invert.means1, as.numeric))
ord <- rda(invert.means2 ~ pH + totalN + Perc_ash + Kalium + Magnesium + Ca + Al + TotalP + OlsenP, abiotic.means2)
ord
mod1 <- lm(invert.means2$Diptera ~ pH + totalN + Perc_ash + Kalium + Magnesium + Ca + Al + TotalP + OlsenP, abiotic.means2)
summary(mod1)
anova(mod1)
ord <- rda(invert.means2 ~ pH + totalN + Perc_ash + Kalium + Magnesium + Ca + Al + TotalP + OlsenP, abiotic.means2)
library(readxl)
setwd("C:/GitHub/R4Eco_2022/Week9")
# First, read in the abiotic data:
# Make sure the excel file is NOT open on your computer or it will generate an error (unlike read.csv)
abiotic.tibble <- read_excel("Penaetal_2016_data.xlsx", sheet = "Abiotic factors")
#Unfortunately, the read_excel function transforms our data into a "tibble" format
# Tibbles are almost as evil as pie charts.
# Or, like cats, tibbles might look pretty but some day they will bite you when you least expect it.
# This can easily be fixed with our old friend as.data.frame:
abiotic <- as.data.frame(abiotic.tibble)
# Nematodes ####
# We'll start by looking at community comparisons between the soil and the nematodes:
# To do this we'll read in the sheet with nematode community data.
# I don't know who goes through the trouble to identify nematodes, but luckily for us these authors did.
nema.tibble <- read_excel("Penaetal_2016_data.xlsx", sheet = "Nematode_community")
nema <- as.data.frame(nema.tibble)
head(nema)
# The first thing to notice here is there are 3 nematode samples per plot, but 5 abiotic samples.
# The location data are compatible, but the number of samples are not.
# The most straightforward correction is to average data by plot to create a 1-to-1 comparison.
# Unfortunately for us, the $plot is repeated by location and type.
# so we need a unique identifier for each plot within each land use, within each location.
# For this, we will turn to the paste() function
abiotic.names <- paste(abiotic$Site, abiotic$Land_Use, abiotic$Plot)
# Then add back in as a column in the data frame:
abiotic$names <- abiotic.names
head(abiotic)
#Same for the nematodes, but with different column names:
nema.names <- paste(nema$Location, nema$Land_use, nema$Plot)
nema$names <- nema.names
#Now we can use aggregate() to create means by the $names column:
abiotic.means <- aggregate(x = abiotic, by = list(abiotic$names), FUN = "mean")
# This created warnings, so we should see what the data frame looks like:
head(abiotic.means)
# Nematodes as well:
nema.means <- aggregate(x = nema, by = list(nema$names), FUN = "mean")
# For our multivariate analysis we need to remove the NA and plot columns:
abiotic.means1 <- abiotic.means[,-16] # NA column
# This also created warnings, so we should see what the data frame looks like:
head(nema.means)
# For our multivariate analysis we need to remove the NA and plot columns:
abiotic.means1 <- abiotic.means[,-16] # NA column
abiotic.means2 <- abiotic.means1[,-1:-6] # Plot and NA columns
abiotic.means2 <- sapply(abiotic.means2, as.numeric ) # Make sure everything is numeric.
abiotic.means2 <- as.data.frame(abiotic.means2) # Make sure it's in the right format.
nema.means1 <- nema.means[,-41] # Remove NAs
nema.means2 <- as.data.frame(nema.means1[,-1:-4]) # Remove plot and NAs
nema.means2 <- sapply(nema.means2, as.numeric )
# And we can FINALLY compare the abiotic data against the biotic communities:
library(vegan)
colnames(abiotic.means2)
ord <- rda(nema.means2 ~ pH + totalN + Perc_ash + Kalium + Magnesium + Ca + Al + TotalP + OlsenP, abiotic.means2)
ord
#63% of the variance explained is pretty good!
# It looks like almost all of it comes from Axis 1
anova(ord)
colnames(abiotic.means2)
ord <- rda(nema.means2 ~ pH + totalN + Perc_ash + Kalium + Magnesium + Ca + Al + TotalP + OlsenP, abiotic.means2)
ord
#63% of the variance explained is pretty good!
# It looks like almost all of it comes from Axis 1
anova(ord)
# But the p-value is not significant. It appears our data might be over-fitted
plot(ord, ylim = c(-2,2), xlim = c(-5,5))
# Based on the View() of the data, we can already tell some of these explanatory variables show exactly the same thing.
# So we will choose our "global" (most complicated) model based on the predictors that are ecologically reasonable.
# In other words, land use is more important than ID.
# Based on the available options, we'll start with this global model:
mod1 <- lm(Leaves ~ pH + totalN + Kalium + Magnesium + Ca + Al + TotalP + Land_use + Species_code,soil.plants)
# The ordistep() and ordiR2step() functions will do this. They use a selection process to keep or remove variables.
# ordistep() will generate p-values with significant predictors.
# ordiR2step() will give the associate R-squared values.
# This is done by removing variables one "step" at a time to see how the predictive ability of the model changes.
# We need to give it a bit of help. The step function needs something to compare against.
# We will use an intercept model, essentially acting as the null hypothesis:
#
ord <- rda(nema.means2 ~., abiotic.means2) # shorthand for the model that includes everything.
ord.int <- rda(nema.means2 ~1, abiotic.means2) # shorthand for the model that only includes intercepts.
# The "both" selection method essentially takes two steps forward, then one step back, and compares the results.
# Then selects which variable to drop and repeats the process
step.mod <- ordistep(ord.int, scope = formula(ord), selection = "both")
step.mod$anova
step.R2mod <- ordiR2step(ord.int, scope = formula(ord), selection = "forward")
# We'll re-run with just nitrogen and look at the results:
ord2 <- rda(nema.means2 ~ totalN, abiotic.means2)
ord2
anova(ord2)
plot(ord2)
#Read in the plant experiment data:
plants.tibble <- read_excel("Penaetal_2016_data.xlsx", sheet = "Data_intro_exp_4_species")
plants <- as.data.frame(plants.tibble)
head(plants)
# Now we need a column to merge our data frames.
# "Parcel" is an identifier I have made sure matches across all of the spreadsheets, where relevant.
# The abiotic means will be more important than individual measurements again, because we do not know which soil sample matches which individual plant.
# The aggregate function calculates means in row order, so we can use the unique() function to create a one-to-one match.
# Then create a column called "Parcel" that allows us to merge with the plants data frame based on Parcel numbers.
abiotic.means2$Parcel <- unique(abiotic$Parcel)
# So we merge by "Parcel" and accept all other defaults.
# Merge can be used for more complex problems if needed (see ?merge). Fortunately, in our data the Parcel match is clear.
soil.plants <- merge(abiotic.means2, plants, by = "Parcel")
# Let's take a quick look at our data.
# This data frame is getting large enough that View() might be more helpful than head() for an initial look:
View(soil.plants)
# We'll quickly do a distribution test of our y (leaves):
library(fitdistrplus)
library(logspline)
#Plot distribution against ideals
##fit all possible/likely distribution models and check AIC/BIC
fit.weibull <- fitdist(soil.plants$Leaves, distr = "weibull")
fit.norm <- fitdist(soil.plants$Leaves, distr = "norm")
fit.gamma <- fitdist(soil.plants$Leaves, distr = "gamma")
fit.lnorm <- fitdist(soil.plants$Leaves, distr = "lnorm")
fit.nbinom <- fitdist(soil.plants$Leaves, distr = "nbinom")
fit.logis <- fitdist(soil.plants$Leaves, distr = "logis")
fit.geom <- fitdist(soil.plants$Leaves, distr = "geom")
#Use AIC comparisons of distributions to see which is best:
#call from:
gofstat(list(fit.weibull, fit.norm, fit.gamma,
fit.lnorm, fit.nbinom, fit.logis, fit.geom))
# While we have not checked the distribution of the $Leaves response, this is a good indication we just might be able to get away with a linear model.
# We will confirm with the residuals.
# Let's look at the available predictor variables before we build the model:
colnames(soil.plants)
# Based on the View() of the data, we can already tell some of these explanatory variables show exactly the same thing.
# So we will choose our "global" (most complicated) model based on the predictors that are ecologically reasonable.
# In other words, land use is more important than ID.
# Based on the available options, we'll start with this global model:
mod1 <- lm(Leaves ~ pH + totalN + Kalium + Magnesium + Ca + Al + TotalP + Land_use + Species_code,soil.plants)
summary(mod1)
anova(mod1)
AIC(mod1)
# Notice the NAs in the summary? We have way too many variables relative to the number of samples.
# We will also look at the model's adjusted R-squared with the following line.
# This is a shorthand to extract the R-squared rather than looking at the entire summary printout:
summary(mod1)$adj.r.squared
#The first step for improving the mode will be to remove Mg, Ca, AL, P, and Land use
# There is not enough variation in these variables to be meaningful (hence the NA's).
mod2 <- lm(Leaves ~ pH + totalN + Kalium + Species_code,soil.plants)
summary(mod2)
anova(mod2)
AIC(mod1,mod2)
# Now we have an AIC to compare against.
# Check the residuals:
plot(mod2$residuals)
summary(mod2)$adj.r.squared
# We'll drop the kalium (aka potassium) from the model now because it's not showing much predictive ability.
mod3 <- lm(Leaves ~ pH + totalN + Species_code,soil.plants)
summary(mod3)
anova(mod3)
AIC(mod2, mod3)
plot(mod3$residuals)
summary(mod3)$adj.r.squared
# So adding kalium back in and looking at interactive effects in soil chemistry is the next step.
mod4 <- lm(Leaves ~ pH*totalN*Kalium + Species_code,soil.plants)
summary(mod4)
anova(mod4)
AIC(mod2,mod3,mod4)
plot(mod4$residuals)
summary(mod4)$adj.r.squared
library(vegan)
colnames(abiotic.means2)
ord <- rda(invert.means2 ~ pH + totalN + Perc_ash + Kalium + Magnesium + Ca + Al + TotalP + OlsenP, abiotic.means2)
ord
colnames(abiotic.means2)
ord <- rda(invert.means2 ~ pH + totalN + Perc_ash + Kalium + Magnesium + Ca + Al + TotalP + OlsenP, abiotic.means2)
ord
anova(ord)
plot(ord, ylim = c(-2,2), xlim = c(-5,5))
ord <- rda(invert.means2 ~., abiotic.means2)
mod1 <- lm(invert.means2$Diptera ~ pH + totalN + Perc_ash + Kalium + Magnesium + Ca + Al + TotalP + OlsenP, abiotic.means2)
summary(mod1)
View(abiotic.means)
mod1 <- lm(invert.means2$Diptera ~ pH + totalN + Perc_ash + Kalium + Magnesium + Ca + Al + TotalP + OlsenP, abiotic.means2)
summary(mod1)
AIC(mod1)
#113.9488
summary(mod1)$adj.r.squared
mod2 <- lm(invert.means2$Diptera ~ totalN + Perc_ash + Ca + Al + TotalP + OlsenP, abiotic.means2)
summary(mod2)
AIC(mod2)
#110.1255
summary(mod2)$adj.r.squared
plot(mod2$residuals)
mod3 <- lm(invert.means2$Diptera ~ totalN + Perc_ash + Ca + OlsenP, abiotic.means2)
summary(mod3)
AIC(mod3)
plot(mod3$residuals)
summary(mod3)
AIC(mod3) #110.1255
summary(mod3)$adj.r.squared #
mod3 <- lm(invert.means2$Diptera ~ totalN + OlsenP, abiotic.means2)
mod4 <- lm(invert.means2$Diptera ~ totalN + OlsenP, abiotic.means2)
mod3 <- lm(invert.means2$Diptera ~ totalN + Perc_ash + Ca + OlsenP, abiotic.means2)
summary(mod3)
AIC(mod3) #112.9541
summary(mod3)$adj.r.squared #0.2033261
mod4 <- lm(invert.means2$Diptera ~ totalN + OlsenP, abiotic.means2)
plot(mod4$residuals)
summary(mod4)
AIC(mod4) #112.9541
summary(mod4)$adj.r.squared #0.2033261
mod4 <- lm(invert.means2$Diptera ~ totalN * OlsenP, abiotic.means2)
mod4 <- lm(invert.means2$Diptera ~ totalN + OlsenP, abiotic.means2)
summary(mod4)
AIC(mod4) #112.2725
summary(mod4)$adj.r.squared #0.1698799
mod5 <- lm(invert.means2$Diptera ~ totalN * OlsenP, abiotic.means2)
summary(mod5)
AIC(mod5) #112.2725
summary(mod5)$adj.r.squared #0.1698799
mod3 <- lm(invert.means2$Diptera ~ totalN * Perc_ash + Ca + OlsenP, abiotic.means2)
summary(mod3)
AIC(mod3) #112.9541
mod3 <- lm(invert.means2$Diptera ~ totalN*Ca + Perc_ash + OlsenP, abiotic.means2)
summary(mod3)
AIC(mod3) #112.9541
mod3 <- lm(invert.means2$Diptera ~ totalN*OlsenP + Perc_ash + Ca, abiotic.means2)
AIC(mod3) #112.9541
mod2 <- lm(invert.means2$Diptera ~ totalN*OlsenP + Perc_ash + Ca + Al + TotalP, abiotic.means2)
summary(mod2)
AIC(mod2) #110.1255
mod1 <- lm(invert.means2$Diptera ~ pH + totalN + Perc_ash + Kalium + Magnesium + Ca + Al + TotalP + OlsenP, abiotic.means2)
summary(mod1)
AIC(mod1) #113.9488
summary(mod1)$adj.r.squared #0.228516
mod2 <- lm(invert.means2$Diptera ~ totalN + Perc_ash + Ca + Al + TotalP + OlsenP, abiotic.means2)
summary(mod2)
AIC(mod2) #110.1255
summary(mod2)$adj.r.squared #0.3511541
mod3 <- lm(invert.means2$Diptera ~ totalN*OlsenP + Perc_ash + Ca + Al + TotalP, abiotic.means2)
summary(mod3)
AIC(mod3) #110.1255
summary(mod3)$adj.r.squared #0.3511541
mod4 <- lm(invert.means2$Diptera ~ totalN + Perc_ash + Ca + OlsenP, abiotic.means2)
summary(mod4)
AIC(mod4) #112.9541
summary(mod4)$adj.r.squared #0.2033261
mod5 <- lm(invert.means2$Diptera ~ totalN*OlsenP + Perc_ash + Ca, abiotic.means2)
summary(mod5)
AIC(mod5) #
summary(mod5)$adj.r.squared #0.
mod6 <- lm(invert.means2$Diptera ~ totalN + OlsenP, abiotic.means2)
summary(mod6)
AIC(mod6) #112.2725
summary(mod6)$adj.r.squared #0.1698799
mod7 <- lm(invert.means2$Diptera ~ totalN * OlsenP, abiotic.means2)
summary(mod7)
AIC(mod7) #101.326
summary(mod7)$adj.r.squared #0.1698799
plot(mod5$residuals)
plot(mod3$residuals)
